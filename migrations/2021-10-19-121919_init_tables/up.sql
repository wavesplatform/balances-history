create extension IF NOT EXISTS btree_gist;

CREATE TABLE IF NOT EXISTS blocks_microblocks (
	uid BIGINT GENERATED BY DEFAULT AS IDENTITY CONSTRAINT blocks_microblocks_uid_pkey PRIMARY KEY,
	id TEXT NOT NULL,
	height INTEGER NOT NULL,
	time_stamp BIGINT NOT NULL,
    is_solidified bool not null default false
);

CREATE INDEX IF NOT EXISTS blocks_microblocks_id_idx ON blocks_microblocks (id);
CREATE INDEX IF NOT EXISTS blocks_microblocks_time_stamp_uid_idx ON blocks_microblocks (time_stamp DESC, uid DESC);
CREATE INDEX IF NOT EXISTS blocks_microblocks_is_solidified_idx ON blocks_microblocks(is_solidified) where is_solidified = false;

create table balance_history (
    balance_history_uid BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY CONSTRAINT balance_history_uid_key UNIQUE,
    recipient TEXT COLLATE "C" NOT NULL,
    asset_id TEXT COLLATE "C" NOT NULL DEFAULT '',
    balance bigint NOT NULL,
    period int8range -- must be as range(blocks_microblocks.uid, blocks_microblocks.uid)
--    EXCLUDE USING gist (recipient with =, asset_id with =,  period WITH &&)
--  ,  PRIMARY KEY (recipient, asset_id, period) INCLUDE (balance)
);

create index on balance_history(asset_id) include(recipient) where upper(period) is null;
create index on balance_history (recipient, asset_id, lower(period));
create index on balance_history (lower(period));
create index on balance_history (upper(period), balance_history_uid);

-- buggy on big data
ALTER TABLE ONLY balance_history ADD CONSTRAINT balance_history_recipient_asset_id_period_excl
    EXCLUDE
    USING gist (recipient WITH =, asset_id WITH =, period WITH &&);

create or replace function insert_or_prolong_balance(in_recipient text, in_asset_id text, block_uid bigint, in_balance bigint, in_balance_prev bigint) returns bigint
    language plpgsql
as $$
DECLARE
    v_bh_uid bigint := NULL;
    v_period int8range;
    v_balance_prev bigint;
BEGIN
    -- search for interval with upper(period) = infinity

    select balance_history_uid, period, balance into v_bh_uid, v_period, v_balance_prev
    from balance_history
    where asset_id = in_asset_id
      and recipient = in_recipient
      and period && int8range(block_uid, null, '[)')
        for update;

    RAISE NOTICE 'balance_history_uid:%; period:%;', v_bh_uid, v_period;

    IF v_bh_uid IS NOT NULL THEN
        BEGIN
            -- IF v_balance_prev != in_balance_prev THEN
            --     RAISE EXCEPTION 'prev balance do not match previous balance_history_uid:%', v_bh_uid;
            -- END IF;

            -- close interval with upper(period) = block_uid only if it was open earlier (and lower(period) < block_uid)
            update balance_history set
                                       period = int8range(lower(period), block_uid, '[)'),
                                       balance = in_balance
            where
                    balance_history_uid = v_bh_uid
              and lower(period) < block_uid;

            IF NOT FOUND THEN
                BEGIN
                    -- passible twice updates balance in one block
                    -- try to simple update balance with same lower(uid) and checks we update only this one

                    update balance_history set
                        balance = in_balance
                    where balance_history_uid = v_bh_uid
                      and lower(period) = block_uid;

                    IF NOT FOUND THEN
                        RAISE EXCEPTION 'balance_history_uid:%; period:%; found later period for block:%;', v_bh_uid, v_period, block_uid;
                    END IF;

                    return v_bh_uid;
                END;
            END IF;

        END;
    END IF;

    insert into balance_history(recipient, asset_id, balance, period)
    values(in_recipient, in_asset_id, in_balance, int8range(block_uid, null, '[)'))
    returning balance_history_uid into v_bh_uid;

    return v_bh_uid;
END;
$$;

create or replace function rollback_balances_to_block_uid(in_block_uid bigint) returns bool
    LANGUAGE plpgsql VOLATILE
AS $$
DECLARE
    del_vals RECORD;
    v_balance_uid BIGINT;
BEGIN
    FOR del_vals IN
        with to_del as (
            delete from balance_history where lower(period) > in_block_uid returning recipient, asset_id
        ) select distinct recipient, asset_id from to_del
    LOOP
            select max(balance_history_uid)
            into v_balance_uid
            from balance_history
            where recipient = del_vals.recipient
                and asset_id = del_vals.asset_id
                and balance_history_uid > in_block_uid
                and not upper(period) is null;

            IF v_balance_uid is NOT NULL THEN
                update balance_history set period = int8range(lower(period), null) where balance_history_uid = v_balance_uid;
            END IF;

    END LOOP;

    return true;

END;
$$;
